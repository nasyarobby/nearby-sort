{"version":3,"file":"sort.module.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Index file for the package\n * @author Yousuf Kalim\n */\n// Distance calculation\nconst getDistance = (lat1: number, lon1: number, lat2: number, lon2: number): number => {\n  const R = 6371; // Radius of the earth in km\n  const dLat = deg2rad(lat2 - lat1); // deg2rad below\n  const dLon = deg2rad(lon2 - lon1);\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  const d = R * c; // Distance in km\n  return d;\n};\n\n// Deg conversion\nconst deg2rad = (deg: number): number => {\n  return deg * (Math.PI / 180);\n};\n\n// Validate the arguments\nconst validateArgs = (lat: number, long: number, arr: any[], asc: boolean): void => {\n  if (\n    isNaN(parseFloat(lat as unknown as string)) ||\n    isNaN(parseFloat(long as unknown as string)) ||\n    !arr\n  ) {\n    throw new Error('Invalid arguments');\n  }\n  if (typeof lat !== 'number' || typeof long !== 'number') {\n    throw new Error('lat and long should be numbers');\n  }\n  if (!Array.isArray(arr)) {\n    throw new Error('Second argument should be an array');\n  }\n  if (typeof asc !== 'boolean') {\n    throw new Error('Asc argument should be a boolean');\n  }\n};\n\n/**\n * Sort the array according to the user's lat long\n * @param lat {Number} - User's latitude\n * @param long {Number} - User's longitude\n * @param arr {Array} - Array of objects that contain lat and long\n * @param asc {Boolean} - Ascending or descending order\n * @returns {Array} - Sorted array\n */\nconst nearbySort = async (\n  { lat, long }: { lat: number; long: number },\n  arr: any[],\n  asc = true,\n): Promise<any[]> => {\n  return await new Promise((resolve, reject) => {\n    try {\n      validateArgs(lat, long, arr, asc);\n      const sortedArray = arr.\n      map(el => {\n        return {...el, d: getDistance(lat, long, el.lat, el.long)}\n      })\n      .sort((a, b) => {\n        return asc ? (a.d - b.d) : (b.d - a.d);\n      });\n      resolve(sortedArray);\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\nexport default nearbySort;\n"],"names":["deg2rad","deg","Math","PI","nearbySort","_ref","arr","asc","lat","long","Promise","resolve","reject","isNaN","parseFloat","Error","Array","isArray","validateArgs","map","el","_extends","d","lat1","lon1","lat2","lon2","dLat","dLon","a","sin","cos","atan2","sqrt","sort","b","err","e"],"mappings":"oOAKA,IAaMA,EAAU,SAACC,GACf,OAAOA,GAAOC,KAAKC,GAAK,IAC1B,EA8BMC,EAAA,SAAUC,EAEdC,EACAC,GAFE,IAAAC,EAAGH,EAAHG,IAAKC,EAAIJ,EAAA,UAEXE,IAAAA,IAAAA,GAAM,GAAI,IACQG,OAAAA,QAAAC,QACL,IAAID,QAAQ,SAACC,EAASC,GACjC,KAjCiB,SAACJ,EAAaC,EAAcH,EAAYC,GAC3D,GACEM,MAAMC,WAAWN,KACjBK,MAAMC,WAAWL,MAChBH,EAED,MAAU,IAAAS,MAAM,qBAElB,GAAmB,iBAARP,GAAoC,iBAATC,EACpC,UAAUM,MAAM,kCAElB,IAAKC,MAAMC,QAAQX,GACjB,MAAM,IAAIS,MAAM,sCAElB,GAAmB,kBAARR,EACT,MAAM,IAAIQ,MAAM,mCAEpB,CAiBMG,CAAaV,EAAKC,EAAMH,EAAKC,GAQ7BI,EAPoBL,EACpBa,IAAI,SAAAC,GACF,OAAAC,EAAWD,CAAAA,EAAAA,GAAIE,GAvDFC,EAuDiBf,EAvDHgB,EAuDQf,EAvDMgB,EAuDAL,EAAGZ,IAvDWkB,EAuDNN,EAAO,KArDxDO,EAAO3B,EAAQyB,EAAOF,GACtBK,EAAO5B,EAAQ0B,EAAOF,GACtBK,EACJ3B,KAAK4B,IAAIH,EAAO,GAAKzB,KAAK4B,IAAIH,EAAO,GACrCzB,KAAK6B,IAAI/B,EAAQuB,IAASrB,KAAK6B,IAAI/B,EAAQyB,IAASvB,KAAK4B,IAAIF,EAAO,GAAK1B,KAAK4B,IAAIF,EAAO,GACjF,EAAI1B,KAAK8B,MAAM9B,KAAK+B,KAAKJ,GAAI3B,KAAK+B,KAAK,EAAIJ,IAN3C,QADQ,IAACN,EAAcC,EAAcC,EAAcC,EAEvDC,EACAC,EACAC,CAoDF,GACCK,KAAK,SAACL,EAAGM,GACR,OAAO5B,EAAOsB,EAAEP,EAAIa,EAAEb,EAAMa,EAAEb,EAAIO,EAAEP,CACtC,GAED,CAAC,MAAOc,GACPxB,EAAOwB,EACR,CACH,GACF,CAAC,MAAAC,GAAA3B,OAAAA,QAAAE,OAAAyB,EAAA,CAAA"}